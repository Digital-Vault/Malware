#!/usr/bin/python3

import os
import socket
import sys
import threading
import paramiko
import signal
from typing import Union
import logging
from logzero import setup_logger, logfile, logger


HOST_KEY_PATH = "test_rsa.key"
MAXIMUM_LISTEN_QUEUE = 100

SERVER_ADDRESS = "localhost"
# TODO change to 22 later
PORT = 2200


DAEMON_USER_ID = 2
DAEMON_GROUP_ID = 2

USERNAME = "test"
PASSWORD = "test"

PID_FILE_PATH = "/tmp/lotteryDaemon.pid"

# TODO probably need to change to /var/lib
LOG_FILE_PATH = "/tmp/sshLog"
LOG_FILE_SIZE_IN_BYTES = 500000
LOG_FILE_BACKUPS = 3

EXIT_ERROR_CODE = 1


class Server(paramiko.ServerInterface):
    def __init__(self):
        self.event = threading.Event()

    def check_channel_request(self, kind, chanid) -> int:
        if kind == "session":
            return paramiko.OPEN_SUCCEEDED
        else:
            return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

    def check_auth_password(self, username, password) -> int:
        if (username == USERNAME) and (password == PASSWORD):
            return paramiko.AUTH_SUCCESSFUL
        else:
            return paramiko.AUTH_FAILED


def main() -> None:
    setup_logger(
        name="paramiko",
        logfile=LOG_FILE_PATH,
        level=logging.WARNING,
        maxBytes=LOG_FILE_SIZE_IN_BYTES,
        backupCount=LOG_FILE_BACKUPS,
        disableStderrLogger=True,
    )

    logfile(
        LOG_FILE_PATH,
        maxBytes=LOG_FILE_SIZE_IN_BYTES,
        backupCount=LOG_FILE_BACKUPS,
        disableStderrLogger=True,
    )

    doubleFork()
    listenForClients()


def doubleFork():
    """Perform a double fork.

    Performs a double fork in order to be inherited by init process.
    The function also tries to set the uid as well as gid of the
    current process. The current directory is changed to /tmp for
    safety reasons.
    """
    try:
        pid = os.fork()
        if not childProcess(pid):
            raise SystemExit(0)
    except OSError:
        logger.error("Failed to fork.")
        raise RuntimeError()

    try:
        os.setuid(DAEMON_USER_ID)
        os.setgid(DAEMON_GROUP_ID)
    except PermissionError as error:
        logger.warning(f"Failed to set user ID and Group ID:\n{error}")

    os.setsid()

    try:
        pid = os.fork()
        if not childProcess(pid):
            raise SystemExit(0)
    except OSError:
        logger.error("Failed to fork.")
        raise RuntimeError()


def childProcess(processId: int) -> bool:
    """Return True if process is a child and False otherwise."""
    return processId == 0


def listenForClients() -> None:
    """Start listening to the clients."""
    addSignalHandlers()

    try:
        serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        serverSocket.bind((SERVER_ADDRESS, PORT))
        serverSocket.listen(MAXIMUM_LISTEN_QUEUE)
    except socket.error as error:
        logger.fatal(f"Failed to listen for clients\n{error}")
        sys.exit(EXIT_ERROR_CODE)

    sshServer = Server()
    hostKey = paramiko.RSAKey(filename=HOST_KEY_PATH)

    while True:
        try:
            clientSocket, _ = serverSocket.accept()
        except socket.error as error:
            logger.fatal(f"Failed to accept\n{error}")
            continue

        processId = os.fork()

        if childProcess(processId):
            serverSocket.close()
            respondToRequest(clientSocket, sshServer, hostKey)


def addSignalHandlers() -> None:
    """Add all the signal handlers for the program.
    
    The following singals are caught:
        * SIGHUP
        * SIGCHLD
    """
    signal.signal(signal.SIGHUP, signal.SIG_IGN)
    signal.signal(signal.SIGCHLD, harvestChildProcess)


def harvestChildProcess(signalNumber, stackFrame) -> None:
    """Harvest a dead child."""
    os.wait()


def respondToRequest(
    connectionSocket: socket.socket, server: Server, hostKey: paramiko.RSAKey
) -> None:
    """Respond the a client request.
    
    Note that this functions exits the program after it's done.
    """

    try:
        with paramiko.Transport(connectionSocket) as sshConnection:
            sshConnection.add_server_key(hostKey)
            sshConnection.start_server(server=server)

            chan: paramiko.Channel = sshConnection.accept()
            print(chan.recv(1024))

            chan.send("\r\nI don't like you.\r\n")
            chan.close()
    except paramiko.SSHException as error:
        logger.error(f"SSH negotiation failed.\n{error}")
    except Exception as error:
        logger.error(f"{error}")

    connectionSocket.close()
    os._exit(os.EX_OK)


if __name__ == "__main__":
    main()
