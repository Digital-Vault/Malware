#!/usr/bin/python3

import os
import socket
import sys
import threading
import paramiko
import signal
from typing import Union
import logging
import argparse
import atexit
from logzero import setup_logger, logfile, logger


HOST_KEY_PATH = "test_rsa.key"
PID_FOLDER_PATH = "/var/run/sshDaemon"
PID_FILE_PATH = f"{PID_FOLDER_PATH}/sshDaemon.pid"

MAXIMUM_LISTEN_QUEUE = 100

SERVER_ADDRESS = "localhost"
PORT = 22


DAEMON_USER_ID = 2
DAEMON_GROUP_ID = 2

USERNAME = "test"
PASSWORD = "test"

LOG_FOLDER_PATH = "/var/log/sshDaemon"
LOG_FILE_PATH = f"{LOG_FOLDER_PATH}/log"
LOG_FILE_SIZE_IN_BYTES = 500000
LOG_FILE_BACKUPS = 3

EXIT_ERROR_CODE = 1


class Server(paramiko.ServerInterface):
    def __init__(self):
        self.event = threading.Event()

    def check_channel_request(self, kind, chanid) -> int:
        if kind == "session":
            return paramiko.OPEN_SUCCEEDED
        else:
            return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

    def check_auth_password(self, username, password) -> int:
        if (username == USERNAME) and (password == PASSWORD):
            return paramiko.AUTH_SUCCESSFUL
        else:
            return paramiko.AUTH_FAILED


def main() -> None:
    """Start the program."""
    if not root():
        sys.exit("You must have run the daemon as root")

    arguments = parseArguments()

    if startServer(arguments.state):
        doubleFork()
        createLogFolder()
        createPidFolder()
        createPidFile()
        flushInputOutput()
        disconnectFromTerminal()
        listenForClients()
    else:
        killTheServer()


def root() -> bool:
    """Return True if user is root and False otherwise."""
    return os.geteuid() == 0


def parseArguments() -> argparse.Namespace:
    """Parse all command line arguments."""
    parser = argparse.ArgumentParser(description="Run SSH Server.")

    parser.add_argument(
        "state", nargs="?", help="start or stop the daemon", default="start"
    )

    parsedArguments = parser.parse_args()

    return parsedArguments


def startServer(state: str) -> bool:
    """Return True if we can start server and False otherwise."""
    if state == "start":
        if alreadyRunning():
            exit("An instance of the server is already running")
        else:
            return True
    else:
        return False


def alreadyRunning():
    """Return True if the server is already running and false otherwise."""
    return os.path.exists(PID_FILE_PATH)


def connectLoggers() -> None:
    """Connect loggers to logzero."""
    setup_logger(
        name="paramiko",
        logfile=LOG_FILE_PATH,
        level=logging.WARNING,
        disableStderrLogger=True,
    )

    logfile(
        LOG_FILE_PATH,
        maxBytes=LOG_FILE_SIZE_IN_BYTES,
        loglevel=logging.WARNING,
        backupCount=LOG_FILE_BACKUPS,
        disableStderrLogger=True,
    )


def doubleFork() -> None:
    """Perform a double fork.

    Performs a double fork in order to be inherited by init process.
    The function also tries to set the uid as well as gid of the
    current process. The current directory is changed to /tmp for
    safety reasons.
    """
    try:
        pid = os.fork()
        if not childProcess(pid):
            raise SystemExit()
    except OSError:
        raise RuntimeError("Failed to fork.")

    try:
        pid = os.fork()
        if not childProcess(pid):
            raise SystemExit()
    except OSError:
        raise RuntimeError("Failed to fork.")


def childProcess(processId: int) -> bool:
    """Return True if process is a child and False otherwise."""
    return processId == 0


def createLogFolder() -> None:
    """Create the log folder if it doesn't exist."""
    try:
        os.mkdir(LOG_FOLDER_PATH, 0o700)
        os.chown(LOG_FOLDER_PATH, DAEMON_USER_ID, DAEMON_GROUP_ID)
    except FileExistsError:
        pass


def createPidFolder() -> None:
    """Create the pid folder if it doesn't exist."""
    try:
        os.mkdir(PID_FOLDER_PATH, 0o700)
        os.chown(PID_FOLDER_PATH, DAEMON_USER_ID, DAEMON_GROUP_ID)
    except FileExistsError:
        pass


def copyRsaFile() -> None:
    """Copy the RSA file required by the server to /var/run."""


def changeUserAndGroup() -> None:
    """Change the user and group to daemon."""
    try:
        os.setgid(DAEMON_GROUP_ID)
        os.setuid(DAEMON_USER_ID)
    except PermissionError as error:
        # TODO change this to exit for production
        print(f"Failed to set user ID and Group ID:\n{error}")

    os.setsid()


def createPidFile() -> None:
    """Create the process ID file."""
    with open(PID_FILE_PATH, "w") as pidFile:
        processId = os.getpid()
        pidFile.write(f"{processId}")

    atexit.register(lambda: os.remove(PID_FILE_PATH))


def flushInputOutput() -> None:
    """Flush out (empty) stdout as well as stderr."""
    sys.stdout.flush()
    sys.stderr.flush()


def disconnectFromTerminal():
    """Disconnect from terminal.

    Disconnect from terminal by changing the stdin, stdout and stderr
    to devnull. This ensures that the process is no longer connected to
    the session.
    """
    with open(os.devnull, "rb", 0) as devNull:
        os.dup2(devNull.fileno(), sys.stdin.fileno())
        os.dup2(devNull.fileno(), sys.stdout.fileno())
        os.dup2(devNull.fileno(), sys.stderr.fileno())


def listenForClients() -> None:
    """Start listening to the clients."""
    addSignalHandlers()

    try:
        serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        atexit.register(lambda: serverSocket.close())

        serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        serverSocket.bind((SERVER_ADDRESS, PORT))
        changeUserAndGroup()
        connectLoggers()

        serverSocket.listen(MAXIMUM_LISTEN_QUEUE)
    except socket.error as error:
        logger.fatal(f"Failed to listen for clients\n{error}")
        sys.exit(EXIT_ERROR_CODE)

    sshServer = Server()
    hostKey = paramiko.RSAKey(filename=HOST_KEY_PATH)
    changeToTempDirectory()

    while True:
        try:
            clientSocket, _ = serverSocket.accept()
        except socket.error as error:
            logger.fatal(f"Failed to accept\n{error}")
            continue

        processId = os.fork()

        if childProcess(processId):
            serverSocket.close()
            respondToRequest(clientSocket, sshServer, hostKey)

        clientSocket.close()


def addSignalHandlers() -> None:
    """Add all the signal handlers for the program.
    
    The following singals are caught:
        * SIGHUP
        * SIGCHLD
        * SIGTERM
    """
    signal.signal(signal.SIGHUP, signal.SIG_IGN)
    signal.signal(signal.SIGCHLD, harvestChildProcess)
    signal.signal(signal.SIGTERM, sigtermHandler)


def harvestChildProcess(signalNumber, stackFrame) -> None:
    """Harvest a dead child."""
    os.wait()


def sigtermHandler(signalNumber, stackFrame) -> None:
    raise SystemExit(EXIT_ERROR_CODE)


def changeToTempDirectory() -> None:
    """Change to /tmp directory.

    This increases the safety of the daemon in case of a compremise.
    """
    os.chdir("/tmp")


def respondToRequest(
    connectionSocket: socket.socket, server: Server, hostKey: paramiko.RSAKey
) -> None:
    """Respond the a client request.
    
    Note that this functions exits the program after it's done.
    """

    try:
        with paramiko.Transport(connectionSocket) as sshConnection:
            sshConnection.add_server_key(hostKey)
            sshConnection.start_server(server=server)

            chan: paramiko.Channel = sshConnection.accept()
            logger.warning(chan.recv(1024))

            chan.send("\r\nI don't like you.\r\n")
            chan.close()
    except paramiko.SSHException as error:
        logger.error(f"SSH negotiation failed.\n{error}")
    except Exception as error:
        logger.error(f"{error}")

    connectionSocket.close()
    os._exit(os.EX_OK)


def killTheServer() -> None:
    """Kill the server if it is already running."""
    if not os.path.exists(PID_FILE_PATH):
        sys.stderr.write("No instance of server running!\n")
        sys.exit(EXIT_ERROR_CODE)

    with open(PID_FILE_PATH, "r") as pidFile:
        processId = int(pidFile.read())
        os.kill(processId, signal.SIGTERM)


if __name__ == "__main__":
    main()
