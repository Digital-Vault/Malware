#!/usr/bin/python3

import os
import socket
import sys
import threading
import paramiko
from typing import Union
import logging
from logzero import setup_logger, logfile, logger


HOST_KEY_PATH = "test_rsa.key"
MAXIMUM_LISTEN_QUEUE = 100

SERVER_ADDRESS = "localhost"
# TODO change to 22 later
PORT = 2200


DAEMON_USER_ID = 2
DAEMON_GROUP_ID = 2

USERNAME = "test"
PASSWORD = "test"

PID_FILE_PATH = "/tmp/lotteryDaemon.pid"

# TODO probably need to change to /var/lib
LOG_FILE_PATH = "/tmp/sshLog"
LOG_FILE_SIZE_IN_BYTES = 500000
LOG_FILE_BACKUPS = 3


class Server(paramiko.ServerInterface):
    def __init__(self):
        self.event = threading.Event()

    def check_channel_request(self, kind, chanid) -> int:
        if kind == "session":
            return paramiko.OPEN_SUCCEEDED
        else:
            return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

    def check_auth_password(self, username, password) -> int:
        if (username == USERNAME) and (password == PASSWORD):
            return paramiko.AUTH_SUCCESSFUL
        else:
            return paramiko.AUTH_FAILED


def main() -> None:
    setup_logger(
        name="paramiko",
        logfile=LOG_FILE_PATH,
        level=logging.WARNING,
        maxBytes=LOG_FILE_SIZE_IN_BYTES,
        backupCount=LOG_FILE_BACKUPS,
        disableStderrLogger=True,
    )

    logfile(
        LOG_FILE_PATH,
        maxBytes=LOG_FILE_SIZE_IN_BYTES,
        backupCount=LOG_FILE_BACKUPS,
        disableStderrLogger=True,
    )

    doubleFork()

    try:
        serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        serverSocket.bind((SERVER_ADDRESS, PORT))
    except socket.error as error:
        errorMessage = f"Failed to Bind to port {PORT}\n{error}"
        logger.fatal(errorMessage)
        sys.exit(errorMessage)

    try:
        serverSocket.listen(MAXIMUM_LISTEN_QUEUE)
        clientSocket, _ = serverSocket.accept()
    except socket.error as error:
        errorMessage = f"Failed to listen or accept\n{error}"
        logger.fatal(errorMessage)
        sys.exit(errorMessage)

    print("Got a connection!")
    hostKey = paramiko.RSAKey(filename=HOST_KEY_PATH)

    try:
        sshConnection = paramiko.Transport(clientSocket)
        sshConnection.add_server_key(hostKey)

        server = Server()
        sshConnection.start_server(server=server)

        chan: paramiko.Channel = sshConnection.accept()

        print(chan.recv(1024))

        chan.send("\r\nI don't like you.\r\n")
        chan.close()

    except paramiko.SSHException as error:
        sys.exit(f"SSH negotiation failed.\n{error}")
    except Exception as error:
        errorMessage = f"Caught exception: {error.__class__}: {error}"

        try:
            sshConnection.close()
        except:
            logger.error("Failed to close SSH connection!")

        logger.fatal(errorMessage)
        sys.exit(errorMessage)


def doubleFork():
    """Perform a double fork.

    Performs a double fork in order to be inherited by init process.
    The function also tries to set the uid as well as gid of the
    current process. The current directory is changed to /tmp for
    safety reasons.
    """
    try:
        pid = os.fork()
        if not childProcess(pid):
            raise SystemExit(0)
    except OSError:
        logger.error("Failed to fork.")
        raise RuntimeError("fork #1 failed.")

    try:
        os.setuid(DAEMON_USER_ID)
        os.setgid(DAEMON_GROUP_ID)
    except PermissionError as error:
        logger.warning(f"Failed to set user ID and Group ID:\n{error}")

    os.setsid()

    try:
        pid = os.fork()
        if not childProcess(pid):
            raise SystemExit(0)
    except OSError:
        logger.error("Failed to fork.")
        raise RuntimeError("fork #2 failed.")


def childProcess(processId: int) -> bool:
    """Return True if process is a child and False otherwise."""
    return processId == 0


if __name__ == "__main__":
    main()
